.bq [T]he aim of functional programming is to transform a program which
describes a problem into a program which describes a solution
-- "Claus Reinke":http://www.haskell.org/pipermail/haskell-cafe/2006-December/020147.html


Procedural programming manipulates values, applying a sequence of builtin operations and other functions to the inputs to produce an output.  Functional programming manipulates functions, applying operations to them and combining them to create a synthetic function which is applied to the input.  A function that takes a function as an argument or returns a function as a result is called (in functional programming) a higher-order function or (in math) a functional.

It defines the standard higher-order functions such as map, reduce (aka foldl), and select (aka filter). It also defines functions for partial function application (curry, rcurry, partial, etc.); and all these functions accept strings that define lambda expressions, such as 'x -> x+1' or 'x+1', as synonyms for the more verbose Javascript expressions such as function(x) {return x+1}.


Functional is a JavaScript library for functional programming.  It
defines the standard higher-order functions (+map+, +reduce+, +filter+) that you can read about elsewhere on the web.
It also defines a functions for partial function application (+curry+, +partial+, etc.) couple of innovations, as well as string lambda expressions, which let you write 'x -> x+1', 'x+1', or even '+1' as an argument to higher-order functions.

See the "example page":/sources/javascripts/functional.html
for more examples and for the documentation.  Get the file "here":/sources/javascripts/functional.js.

Functional is known to work in Firefox 2.0 and Safari 3.0.  I didn't intentionally use any non-standard ECMAScript constructs, but meta-programming such as this tends to turn up corners in the browser implementations.

h4. String lambdas

Welcome to FP!  You've discovered +map+ and +filter+.  Try using them in JavaScript.  Isn't this a pain?:
  map(function(x){return x+1}, [1,2,3])
    -> [2,3,4]
  filter(function(x){return x>2}, [1,2,3,4]]
    -> [3,4]
  some(function(w){return w.length < 3}, 'are there any short words?'.split(' '))
    ->false

String lambdas let you write these instead:
  map('x+1', [1,2,3])
  select('x>2', [1,2,3,4])
  some('_.length < 3', 'are there any short words?'.split(' '))

A string lambda can take any of these forms (the example page and documentation discuss the tradeoffs among them):
  x -> x+1
  x+1
  +1
  x, y -> x + y
  x + y
  +
Chain '->' to create function-returning functions:
  x -> y -> x + y

Some more examples:
  // double the items in a list
  map('_/2', [1,2,3])
  # -> [2, 4, 6]
  // find the odd numbers
  select('%2', [1,2,3,4])
  # -> [1, 3]
  // or the evens numbers
  select(not('%2'), [1,2,3,4])
  # -> [2, 4]
  // find the length of the longest word
  reduce(Math.max, 0, map('_.length', 'how long is the longest word?'.split(' ')))
  # -> 7
  // parse a binary array
  reduce('2*x+y', 0, [1,0,1,0])
  # -> 10
  // parse a (non-negative) decimal string
  reduce('x*10+y', 0, map('.charCodeAt(0)-48', '123'.split(/(?=.)/)))
  # -> 123

Here's how to use +compose+ and +curry+ to generalize some of these examples
into reusable functions.  I'm betting you'll like/hate these function definitions to the
extent that you like/hate Haskell.
  var longest = compose(reduce.curry(Math.max, 0), map.curry('_.length'), "_.split(' ')");
  longest("how long is the longest word?");
  # ->
  longest("I bet floccinaucinihilipipification is longer.");
  # -> 29
  var parseUnsignedInt = compose(reduce.curry('x*10+y.charCodeAt(0)-48', 0), '_.split(/(?=.)/)')
  parseUnsignedInt('123')
  # -> 123


h4. Partial function application

Partial function application, or specialization, creates a new
function out of an old one.  For example, given a division function:
  function div(a, b) {return a/b}
a partial application of +div+ is a new function that divides its argument by two:
  var halve = div.partial(_, 2);
Partial application is especially useful as an argument to the higher-order functions such as +map+, where, given a function +div+, we can apply it (the first line below) without an explicit wrapper (the second).
  map(div.partial(_, 10), [10, 20, 30])
  map(lambda(n) {return div(n, 10)}, [10, 20, 30])

+curry+ is a special case of partial function application, and the prevous example could have been handled via +curry+.  Partial function
application in all its generality is only necessary when you're
specializing not just on all the arguments on the left, or all the
arguments on the right, but some distribution of arguments with holes
in the middle.  To illustrate this requires a function with more than two
parameters.

JavaScript doesn't have many functions with more than two parameters. (+splice+ takes three, but +splice+ isn't very functional).  Here's a contrived example, to start (and a real-world example next).

We'll borrow one of the few trinary predicates from math: "between".  +increasing+ tests whether +b+ (the middle argument) lies in the open interval bounded by +a+ and +c+.  Specializing the first and last arguments produces functions that test whether a number is positive, or negative.

  function increasing(a, b, c) {
    return a < b && b < c;
  }
  var positive = increasing.partial(0, _, Infinity);
  map(positive, [-1, 0, 1])
    -> [false, false, true]
  var negative = increasing.partial(-Infinity, _, 0);
  map(negative, [-1, 0, 1]) 
    -> [true, false, false]

A real-world example:  If you're using Prototype, you can replace the first line below by the second:
  Event.observe('myobj', 'click', function() {...})
  onclick(''myobj', function() {...})
by defining a specialized version of Event.observe:
    var onclick = Event.observe.bind(Event).partial(_, 'click');

Is this better than the following?
  function onclick(element, handler) {
    Event.observe(elenent, 'click', handler);
  }

It's a matter of taste, with some performance considerations as well.  The functional version is less efficient, and to the untrained eye it's harder to read.  This version is not just functional, but "function-level":"http://en.wikipedia.org/wiki/Function-level_programming".  It's in a style that has been called "point-free":http://haskell.org/haskellwiki/Pointfree (and even pointless:"http://haskell.org/haskellwiki/Pointfree#Problems_with_pointfree").

On the other hand, the functional version doesn't include as much
plumbing, with its attendent opportunity for error.  The second
definition  of +onclick+, considered as a general replacement for Event.observer(..., 'click', ...), has two such errors.  One shows up as soon as
you use it; the second is considerably more subtle.  Whether functional programming is appropriate, for reasons of efficiency or readability, in any particular instance, it's nice to have it, at lest for prototyping, in your arsenal.

h4. Future Directions

Functional programming doesn't always mesh well with OO, especially with Javascript's absence of bound methods.  There are currently two sets of methods to partially apply a function: +bind+ binds its receiver (the first argument to +apply+); and [r][n]curry and +partial+ bind the other arguments (the arguments to +call+, which list is the second argument to +apply+).

One problem with this is the syntax.  If you want to specialize both the receiver and the parameters, such as in the example with Event.observe above, you need two chained function calls.  This is a tradeoff: it's because each of +bind+ and +partial+ does a single thing.  I considered adding a single omnibus function that bound everything, but it looked just as verbose, and more confusing, than the present solution.

The other problem is performance.  Invoking the function returned by fn.bind(a) goes through one extra function call beyond the cost of invoking fn().  That's unavoidable.  Invoking the function returned by fn.partial(b,c) also goes through one extra function call (as well as a loop and some conditionals to merge the argument lists).  That's unavoidable too.  But a call to the function returned by fn.bind(a).partial(b,c) or fn.partial(b,c).bind(a) goes through *two* extra function calls.  It only needs one.

Someday I'll publish fast-functional.js, which patches functional.js to fix this problem.  It modifies fn.bind(a).partial(b,c) and fn.partial(b,c).bind(a) to return a function that calls the underlying function directly, instead of trampolining once for each method in the chain.  Later I'll describe a generalization of this technique, for defining function algebras with combinatoric reductions.

h4. Credits

I bummed the +[].slice.call(arguments, 0)+ idiom from http://www.coryhudson.com/blog/2007/03/10/javascript-currying-redux, and used it all over the place to avoid an iteratio or a non-native function call.  The ECMAScript Language Specification is careful to define +slice+ in such a way that this works, but I don't think I would have thought of it.


Agenda:
- osdoc: click on examples
- doc portability
- add +specialize+, same as partial but doesn't curry; "non-standard distinction"
- add returning (wraps, and returns this)
- move reporting() to osdoc; or lift from zardoz
- add intercept; demonstrate it on prototype; add prototype library
- add jsmin version
- note about implementation style: keep eval out of the top
Blog:
- functional programming and function-level programming
- add iframe version
Later:
- 
- add prototype library
- rename receiver
- add methods to string?
- environments
OSDoc:
- add version number
- factor 'reporting'
- doc requirements

chain(fn, args) { // after?
  var self = this;
  var args = 
  return function() {
    return fn.apply(this, [self.apply(this, arguments)].concat(args));
  }
}

//Function.prototype.postfilter = Functional.sequence.curry;


// make sure this doesn't overwrite the other one
s

// This is useful to remove optional arguments from a function that is passed
// to a higher-order function that supplies *different* optional arguments.
// For example, Prototype's +Event.observe+ takes an optional final argument,
// and +Enumerable.each+ supplies one, so this won't work as expected:
//   $$('p').each(Event.s
// '[a,b]'.lambda()(1,2) => [1, 2]
// '[a,b]'.lambda().arity(1)(1,2) => [1, undefined]
Function.prototype.arity = function(n) {
  var fn = this;
  return function() {
    return fn.apply(this, [].slice.call(arguments, 0, n);
  }
]

// +compose+ returns a function that ap
// == f.compose(g)(args...) == g(f(args...))
// == f.compose(g)(args...) == Functional.compose(g, f)
// Note that, unlike +Functional.compose+, the +compose+ method on
// function only takes a single argument.
Function.prototype.compose = function(fn) {
  return function() {
    return fn.apply(this, [self.apply(this, arguments)]);
  }
}

// ^^ Filters
// 
// Filters intercept a value before it is passed to a function, and apply the
// underlying function to the modified value.

// +filterObject+ returns a function that applies the underlying function
// to the same arguments, but to an object that is the result of appyling
// +filter+ to the invocation object.
// == fn.filterObject(filter).apply(object, args...) == fn.apply(filter(object), args...)
// == fn.bind(object) == compose(fn.filterObject, Function.K(object))
// >> 'this'.lambda().filterObject('n+1').apply(1) -> 2
Function.prototype.filterObject = function(filter) {
  filter = Function.toFunction(filter);
  var fn = this;
  return function() {
    return fn.apply(filter(this), arguments);
  }
}

// +prefilterAt+ returns a function that applies the underlying function
// to a copy of the arguments, where the +index+th argument has been
// replaced by +filter(argument[index])+.
// == fn.prefilterAt(i, filter)(a1, a2, ..., an) == fn(a1, a2, ..., filter(ai), ..., an)
>> '[a,b,c]'.lambda().prefilterAt(1, '2*')(2,3,4) -> [2, 6, 4]
Function.prototype.prefilterAt = function(index, filter) {
  filter = Function.toFunction(filter);
  var fn = this;
  return function() {
    var args = 
    args[index] = filter.apply(this, args[index]);
    return fn.apply(this, args);
  }
}

// +prefilterAt+ returns a function that applies the underlying function
// to a copy of the arguments, where the arguments +start+ through
// +end+ have been replaced by +filter(argument.slice(start,end))+.
// == fn.prefilterAt(i, filter)(a1, a2, ..., an) == fn(a1, a2, ..., filter(ai), ..., an)
// == fn.prefilterSlice(i0, i1, filter)(a1, a2, ..., an) == fn(a1, a2, ..., filter(ai0, ..., ain), ..., an)
>> '[a,b,c]'.lambda().prefilterSlice('+', 1, 2)(1,2,3,4) -> [1,5,4]
>> '[a,b]'.lambda().prefilterSlice('+', 1)(1,2,3) -> [1,5]
>> '[a]'.lambda().prefilterSlice(Math.max)(1,2,3) -> [3]
Function.prototype.prefilterSlice = function(start, end, filter) {
  filter = Function.toFunction(filter);
  var fn = this;
  return function() {
    var args = 
    args.splice.apply(args, [start, end].concat(filter.apply(this, [].slice.call(filterArgs, start, end))));
    return fn.apply(this, args);
}

 @parameters filter
postfilter = Functional.compose.curry.compose(Function.toFunction);

wrappedBy = function() {}

// Returns a function that has the same effect as this function, but returns
// itself.  This is useless for pure-functional functions, but can be used
// to make chainable methods in procedural/OO code.
// == f.returning.apply(this, args...) == this, but with side effect of f()
// >> var value = 1
// >> (function(a, b){value=[this, a, b]; return 4}).call(1, 2, 3) -> 4
// >> value => [1, 2, 3]
// >> value = 1
// >> (function(a, b){value=[this, a, b]; return 4}).returning().call(1, 2, 3) -> 1
// >> value => [1, 2, 3]
Function.returning = function(/*args...*/) {
  var fn = this;
  return function() {
    fn.apply(this, arguments) ;
    return fn;
  }
}

// Returns a function that is equivalent to the underlying function when
// +guard+ returns true, and otherwise is equivalent to the application
// of +otherwise+ to the same arguments.
// 
// +guard+ defaults to +Function.I+ (which tests for true, in this contextt),
// and +otherwise+ defaults to +Function.K(null)+ (which returns null).
// == f.guard(g, h)(args...) == f(args...), when g(args...) is true
// == f.guard(g ,h)(args...) == h(args...), when g(args...) is false
// >> '[_]'.lambda().guard()(1) -> [1]
// >> '[_]'.lambda().guard()(null) -> null
// >> '[_]'.lambda().guard()(null, Function.K('-')) -> '-'
// >> 'x+1'.lambda().guard('<10')(1) -> 2
// >> 'x+1'.lambda().guard('<10')(10) -> null
// >> 'x+1'.lambda().guard('<10', Function.I)(10) -> 10
// >> '/'.lambda().guard('p q -> q != 0', Function.K('/0'))(1, 2) -> 0.5
// >> '/'.lambda().guard('p q -> q != 0', Function.K('/0'))(1, 0) -> '/0'
Function.prototype.guard = function(guard, otherwise) {
  var fn = this;
  guard = Function.toFunction(guard || Function.I);
  otherwise = Function.toFunction(otherwise || Function.K(null));
  return function() {
    return (guard.apply(this, arguments) ? this : otherwise)(this, arguments);
  }
}

// install on proto Array each; Enumerable all any collect detect each find findAll
// grep: 2 inject 2, map min 2, partition reject select sortBy; 
//synonyms: Array.each Hash.each
'all any collect detect each find findAll map partition reject select sortBy grep[1] inject[1] min[1]'.each(function(name) {
  var index = 0;
  var parts = name.split(/\[\]/);
  if (parts) {name = parts[0]; index = parseInt(parts[1]]
  // excpet: they can be nulls
  if (typeof iterable[name] == 'function')
    Iterable[name] = wrapped(iterable[name]);
Function.toFunction.guard(Function.K)
  wrapped = Functonal.prefilterAt.rcurry(_, 0, Function.toFunction.rcurry(true));
}

Number.prototype.times = function(fn, receiver) {
    var limit = Math.max(0, this);
    for (var i = 0; i < limit; i++)
        fn.call(receiver, i);
}

// var oldRequest = Ajax.Request;
// Ajax.Request = (function() {
//     return function(url, options) {
//         info(arguments);
//         return oldRequest("functional-examples.js", arguments[1]);
//         return oldRequest.apply(Ajax, arguments);
//         if (options.onSuccess)
//             options.onSuccess = options.onSuccess.reporting();
//         return oldRequest.apply(this, url, [options].concat([].slice.call(arguments, 2)));
//     }
// })(Ajax.Request);

// 
// If +binding+ is supplied, it acts an environment for the new function.
// >> 'x -> x+a'.lambda({a:1})(2)
String.prototype.lambda = function(binding) {
    
    var body = 'return (' + expr + ')';
    alert(binding, new Function(params, body));
        with (binding)
            return new Function(params, body);
